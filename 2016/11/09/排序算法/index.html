<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <meta name="renderer" content="webkit">
  <meta http-equiv="X-UA-Compatible" content="IE=edge" >
  <link rel="dns-prefetch" href="//litten.me">
  <title>排序算法 | 王瑄的博客</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="即使你只是使用标准库中的排序函数，学习排序算法仍有三大实际意义：

对排序算法的分析将有助于你全面理解本书中比较算法性能的方法；
类似的技术也能有效解决其他类型的问题；
排序算法常常是我们解决其他问题的第一步。

更重要的是，这些算法都很经典、优雅和高效。

排序算法的比较器
此比较器通过让各排序算法对T个长度为N的数组排序，进行两两比较，观察算法的性能。其中需要传入的参数为(举例说明)：Mer">
<meta property="og:type" content="article">
<meta property="og:title" content="排序算法">
<meta property="og:url" content="//litten.me/2016/11/09/排序算法/index.html">
<meta property="og:site_name" content="王瑄的博客">
<meta property="og:description" content="即使你只是使用标准库中的排序函数，学习排序算法仍有三大实际意义：

对排序算法的分析将有助于你全面理解本书中比较算法性能的方法；
类似的技术也能有效解决其他类型的问题；
排序算法常常是我们解决其他问题的第一步。

更重要的是，这些算法都很经典、优雅和高效。

排序算法的比较器
此比较器通过让各排序算法对T个长度为N的数组排序，进行两两比较，观察算法的性能。其中需要传入的参数为(举例说明)：Mer">
<meta property="og:updated_time" content="2016-11-09T02:10:49.374Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="排序算法">
<meta name="twitter:description" content="即使你只是使用标准库中的排序函数，学习排序算法仍有三大实际意义：

对排序算法的分析将有助于你全面理解本书中比较算法性能的方法；
类似的技术也能有效解决其他类型的问题；
排序算法常常是我们解决其他问题的第一步。

更重要的是，这些算法都很经典、优雅和高效。

排序算法的比较器
此比较器通过让各排序算法对T个长度为N的数组排序，进行两两比较，观察算法的性能。其中需要传入的参数为(举例说明)：Mer">
  
    <link rel="alternative" href="/atom.xml" title="王瑄的博客" type="application/atom+xml">
  
  
    <link rel="icon" href="/assets/img/favicon.ico">
  
  <link rel="stylesheet" href="/main.css">
  

</head>

<body>
  <div id="container">
    <div class="left-col">
      <div class="overlay"></div>
<div class="intrude-less">
	<header id="header" class="inner">
		<a href="/" class="profilepic">
			
			<img src="/assets/blogImg/wx.png" class="js-avatar">
			
		</a>

		<hgroup>
		  <h1 class="header-author"><a href="/">Demons</a></h1>
		</hgroup>

		
		<p class="header-subtitle">朝九晚五，浪迹天涯。</p>
		

		<nav class="header-menu">
			<ul>
			
			</ul>
		</nav>
		<nav class="header-smart-menu">
	        
    		
    			
    			<a class="js-smart-menu" data-idx="0" href="javascript:void(0)">所有文章</a>
    			
    			
            
    			
    			<a class="js-smart-menu" data-idx="1" href="javascript:void(0)">标签</a>
    			
    			
            
    			
            
    			
    			<a class="js-smart-menu" data-idx="2" href="javascript:void(0)">关于我</a>
    			
    			
            
		</nav>
		<nav class="header-nav">
			<div class="social">
				
					<a class="github" target="_blank" href="https://github.com/Demons-wx" title="github">github</a>
		        
					<a class="weibo" target="_blank" href="http://weibo.com/u/5869423338" title="weibo">weibo</a>
		        
					<a class="rss" target="_blank" href="/wangxuan" title="rss">rss</a>
		        
			</div>
		</nav>
	</header>		
</div>

    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
  	<div class="overlay">
  		<div class="slider-trigger"><i class="icon-list"></i></div>
  		<h1 class="header-author js-mobile-header hide">Demons</h1>
  	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<div class="profilepic">
				
					<img src="/assets/blogImg/wx.png" class="js-avatar">
				
			</div>
			<hgroup>
			  <h1 class="header-author">Demons</h1>
			</hgroup>
			
			<p class="header-subtitle">朝九晚五，浪迹天涯。</p>
			
			<nav class="header-menu">
				<ul>
				
				</ul>
			</nav>
			<nav class="header-nav">
				<div class="social">
					
						<a class="github" target="_blank" href="https://github.com/Demons-wx" title="github">github</a>
			        
						<a class="weibo" target="_blank" href="http://weibo.com/u/5869423338" title="weibo">weibo</a>
			        
						<a class="rss" target="_blank" href="/wangxuan" title="rss">rss</a>
			        
				</div>
			</nav>
		</header>				
	</div>
</nav>

      <div class="body-wrap">
        <article id="post-排序算法" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      排序算法
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <blockquote>
<p>即使你只是使用标准库中的排序函数，学习排序算法仍有三大实际意义：</p>
<ul>
<li>对排序算法的分析将有助于你全面理解本书中比较算法性能的方法；</li>
<li>类似的技术也能有效解决其他类型的问题；</li>
<li>排序算法常常是我们解决其他问题的第一步。</li>
</ul>
<p>更重要的是，这些算法都很经典、优雅和高效。</p>
</blockquote>
<h4 id="排序算法的比较器"><a href="#排序算法的比较器" class="headerlink" title="排序算法的比较器"></a>排序算法的比较器</h4><blockquote>
<p>此比较器通过让各排序算法对T个长度为N的数组排序，进行两两比较，观察算法的性能。其中需要传入的参数为(举例说明)：<br><code>Merge Quick T N</code><br>得到的结果为：<br><code>Merge cost time 0.21s 
Quick cost time 0.18s 
For 100 random Doubles Merge is 0.9 times faster than Quick</code></p>
</blockquote>
<a id="more"></a>
<p>代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> sort;</div><div class="line"></div><div class="line"><span class="keyword">import</span> sort.merge.Merge;</div><div class="line"><span class="keyword">import</span> sort.merge.MergeBU;</div><div class="line"><span class="keyword">import</span> sort.quick.Quick;</div><div class="line"><span class="keyword">import</span> sort.quick.Quick3way;</div><div class="line"><span class="keyword">import</span> sort.selection.Selection;</div><div class="line"><span class="keyword">import</span> sort.heap.Heap;</div><div class="line"><span class="keyword">import</span> sort.insertion.Insertion;</div><div class="line"><span class="keyword">import</span> sort.shell.Shell;</div><div class="line"><span class="keyword">import</span> edu.princeton.cs.algs4.StdOut;</div><div class="line"><span class="keyword">import</span> edu.princeton.cs.algs4.StdRandom;</div><div class="line"><span class="keyword">import</span> fundamentals.algorithmsanalysis.Stopwatch;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * 各种排序算法的性能比较</div><div class="line"> * <span class="doctag">@author</span> Demons</div><div class="line"> *</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SortCompare</span> </span>&#123;</div><div class="line">	</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">double</span> <span class="title">time</span><span class="params">(String alg, Double[] a)</span></span>&#123;</div><div class="line">		Stopwatch timer = <span class="keyword">new</span> Stopwatch();</div><div class="line">		<span class="keyword">if</span>(alg.equals(<span class="string">"Insertion"</span>)) Insertion.sort(a);</div><div class="line">		<span class="keyword">if</span>(alg.equals(<span class="string">"Selection"</span>)) Selection.sort(a);</div><div class="line">		<span class="keyword">if</span>(alg.equals(<span class="string">"Shell"</span>)) Shell.sort(a);</div><div class="line">		<span class="keyword">if</span>(alg.equals(<span class="string">"Merge"</span>)) Merge.sort(a);</div><div class="line">		<span class="keyword">if</span>(alg.equals(<span class="string">"MergeBU"</span>)) MergeBU.sort(a);</div><div class="line">		<span class="keyword">if</span>(alg.equals(<span class="string">"Quick"</span>)) Quick.sort(a);</div><div class="line">		<span class="keyword">if</span>(alg.equals(<span class="string">"Quick3way"</span>)) Quick3way.sort(a);</div><div class="line">		<span class="keyword">if</span>(alg.equals(<span class="string">"Heap"</span>)) Heap.sort(a);</div><div class="line">		<span class="keyword">return</span> timer.elapsdTime();</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">double</span> <span class="title">timeRandomInput</span><span class="params">(String alg, <span class="keyword">int</span> N, <span class="keyword">int</span> T)</span></span>&#123;</div><div class="line">		<span class="comment">// 使用算法将T个长度为N的数组排序</span></div><div class="line">		<span class="keyword">double</span> total = <span class="number">0.0</span>;</div><div class="line">		Double[] a = <span class="keyword">new</span> Double[N];</div><div class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> t = <span class="number">0</span>; t &lt; T; t++) &#123;</div><div class="line">			<span class="comment">// 进行一次测试 (生成一个数组并排序)</span></div><div class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;N; i++)&#123;</div><div class="line">				a[i] = StdRandom.uniform();</div><div class="line">			&#125;</div><div class="line">			total += time(alg, a);</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">return</span> total;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">		String alg1 = args[<span class="number">0</span>];</div><div class="line">		String alg2 = args[<span class="number">1</span>];</div><div class="line">		<span class="keyword">int</span> N = Integer.parseInt(args[<span class="number">2</span>]);</div><div class="line">		<span class="keyword">int</span> T = Integer.parseInt(args[<span class="number">3</span>]);</div><div class="line">		<span class="keyword">double</span> t1 = timeRandomInput(alg1, N, T);	<span class="comment">// 算法1的总时间</span></div><div class="line">		<span class="keyword">double</span> t2 = timeRandomInput(alg2, N, T); 	<span class="comment">// 算法2的总时间</span></div><div class="line">		StdOut.printf(<span class="string">"%s cost time %.2fs \n"</span>, alg1, t1);</div><div class="line">		StdOut.printf(<span class="string">"%s cost time %.2fs \n"</span>, alg2, t2);</div><div class="line">		StdOut.printf(<span class="string">"For %d random Doubles %s is"</span>, N, alg1);</div><div class="line">		StdOut.printf(<span class="string">" %.1f times faster than %s\n"</span>, t2/t1, alg2);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>其中用到了一个自定义计时器<code>StopWatch</code>，代码如下所示：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> fundamentals.algorithmsanalysis;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Stopwatch</span> </span>&#123;</div><div class="line"></div><div class="line">	<span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> start;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Stopwatch</span><span class="params">()</span></span>&#123;</div><div class="line">		start = System.currentTimeMillis();</div><div class="line">	&#125;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">elapsdTime</span><span class="params">()</span></span>&#123;</div><div class="line">		<span class="keyword">long</span> now = System.currentTimeMillis();</div><div class="line">		<span class="keyword">return</span> (now - start) / <span class="number">1000.0</span>;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h4><blockquote>
<p>思想：</p>
<ul>
<li>首先，找到数组中最小的那个元素；</li>
<li>其次，将它和数组中第一个元素交换位置，(如果第一个元素就是最小元素，那么它就和自己交换位置)；</li>
<li>再次，在剩下的元素中找到最小的元素，将它与数组的第二个元素交换位置。如此往复直到整个数组有序。</li>
</ul>
<p>特点：</p>
<ul>
<li>运行时间和输入无关。已经有序的数组和一个元素随机排列的数组所用的排序时间竟然一样</li>
<li>数据移动是最少的。每次交换都会改变两个数组元素的值，因此选择排序用了N次交换，交换次数和数组的大小是线性关系。我们将研究的其他任何算法都不具备这种特征。</li>
</ul>
<p>对于长度为N的数组，选择排序需要大约N^2/2次比较和N次交换。</p>
</blockquote>
<p>代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> sort.selection;</div><div class="line"></div><div class="line"><span class="keyword">import</span> edu.princeton.cs.algs4.StdOut;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * 选择排序</div><div class="line"> * <span class="doctag">@author</span> Demons</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Selection</span> </span>&#123;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparable[] a)</span></span>&#123;</div><div class="line">		<span class="comment">// 将 a[] 按升序排列</span></div><div class="line">		<span class="keyword">int</span> N = a.length;</div><div class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</div><div class="line">			<span class="comment">// 将a[i]和a[i+1...N]中最小的元素交换</span></div><div class="line">			<span class="keyword">int</span> min = i;</div><div class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = i+<span class="number">1</span>; j &lt; N; j++) &#123;</div><div class="line">				<span class="keyword">if</span>(less(a[j],a[min]))&#123;</div><div class="line">					min = j;</div><div class="line">				&#125;</div><div class="line">			&#125;</div><div class="line">			exch(a, i, min);</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">less</span><span class="params">(Comparable v, Comparable w)</span></span>&#123;</div><div class="line">		<span class="keyword">return</span> v.compareTo(w) &lt; <span class="number">0</span>;</div><div class="line">	&#125;</div><div class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">exch</span><span class="params">(Comparable[] a, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span>&#123;</div><div class="line">		Comparable t = a[i];</div><div class="line">		a[i] = a[j];</div><div class="line">		a[j] = t;</div><div class="line">	&#125;</div><div class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">(Comparable[] a)</span></span>&#123;</div><div class="line">		<span class="comment">// 在单行中打印数组</span></div><div class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;a.length; i++)&#123;</div><div class="line">			StdOut.print(a[i]+<span class="string">" "</span>);</div><div class="line">		&#125;</div><div class="line">		StdOut.println();</div><div class="line">	&#125;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isSorted</span><span class="params">(Comparable[] a)</span></span>&#123;</div><div class="line">		<span class="comment">// 测试数组元素是否有序</span></div><div class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;a.length; i++)&#123;</div><div class="line">			<span class="keyword">if</span>(less(a[i], a[i-<span class="number">1</span>]))&#123;</div><div class="line">				<span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h4><blockquote>
<p>思路：</p>
<ul>
<li>将第i个元素插入到前面已经有序的i-1个元素中。</li>
<li>首先，将a[i]和a[i-1]比较，如果a[i] &lt; a[i-1] 交换位置</li>
<li>继续比较，a[i-1]和a[i-2]，小于则继续交换，大于则交换停止，此时a[]中前i个元素已经有序</li>
</ul>
<p>性能：</p>
<ul>
<li>最好情况下：需要N-1次比较和0次交换。</li>
<li>平均情况下：需要~ N^2/4次比较和~ N^2/4次交换</li>
<li>最坏情况下：需要~ N^2/2次比较和~ N^2/2次交换</li>
</ul>
</blockquote>
<p>代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> sort.insertion;</div><div class="line"></div><div class="line"><span class="keyword">import</span> edu.princeton.cs.algs4.StdOut;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * 插入排序</div><div class="line"> * <span class="doctag">@author</span> Demons</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Insertion</span> </span>&#123;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparable[] a)</span></span>&#123;</div><div class="line">		<span class="comment">// 将a[]按升序排列</span></div><div class="line">		<span class="keyword">int</span> N = a.length;</div><div class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;N; i++)&#123;</div><div class="line">			<span class="comment">// 将a[i] 插入到a[i-1]、a[i-2]、a[i-3]...之中</span></div><div class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> j=i; j&gt;<span class="number">0</span> &amp;&amp; less(a[j], a[j-<span class="number">1</span>]); j--)&#123;</div><div class="line">				exch(a, j, j-<span class="number">1</span>);</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	<span class="comment">// 比较</span></div><div class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">less</span><span class="params">(Comparable v, Comparable w)</span></span>&#123;</div><div class="line">		<span class="keyword">return</span> v.compareTo(w) &lt; <span class="number">0</span>;</div><div class="line">	&#125;</div><div class="line">	<span class="comment">// 交换</span></div><div class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">exch</span><span class="params">(Comparable[] a, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span>&#123;</div><div class="line">		Comparable t = a[i];</div><div class="line">		a[i] = a[j];</div><div class="line">		a[j] = t;</div><div class="line">	&#125;</div><div class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">(Comparable[] a)</span></span>&#123;</div><div class="line">		<span class="comment">// 在单行中打印数组</span></div><div class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;a.length; i++)&#123;</div><div class="line">			StdOut.print(a[i]+<span class="string">" "</span>);</div><div class="line">		&#125;</div><div class="line">		StdOut.println();</div><div class="line">	&#125;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isSorted</span><span class="params">(Comparable[] a)</span></span>&#123;</div><div class="line">		<span class="comment">// 测试数组元素是否有序</span></div><div class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;a.length; i++)&#123;</div><div class="line">			<span class="keyword">if</span>(less(a[i], a[i-<span class="number">1</span>]))&#123;</div><div class="line">				<span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">	&#125;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">		<span class="comment">// 从标准输入中读取字符串，将他们排序并输出</span></div><div class="line">		Integer[] a = &#123;<span class="number">8</span>,<span class="number">4</span>,<span class="number">22</span>,<span class="number">45</span>,<span class="number">1</span>,<span class="number">23</span>,<span class="number">67</span>&#125;; <span class="comment">// Integer数组实现了Comparable接口</span></div><div class="line">		sort(a);</div><div class="line">		<span class="function"><span class="keyword">assert</span> <span class="title">isSorted</span><span class="params">(a)</span>:"数组未排序"</span>;</div><div class="line">		show(a);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>总体来说，插入排序对于部分有序的数组十分高效，也很适合小规模数组。这很重要，因为这些类型的数组在实际应用中经常出现，而且它们也是高级排序算法的中键过程。我们在学习高级排序算法时会再次接触插入排序。</p>
<h4 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h4><blockquote>
<p>思想：</p>
<ul>
<li>使数组中任意间隔为h的元素都是有序的，这样的数组被称为h有序数组。</li>
<li>换句话说，一个h有序的数组就是h个互相独立的有序数组编织在一起组成的一个数组。</li>
<li>h初始值 &gt; N/3，h=h/3，当h递减到1时，排序完成。</li>
</ul>
</blockquote>
<p>代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> sort.shell;</div><div class="line"></div><div class="line"><span class="keyword">import</span> edu.princeton.cs.algs4.In;</div><div class="line"><span class="keyword">import</span> edu.princeton.cs.algs4.StdOut;</div><div class="line"><span class="comment">/**</span></div><div class="line"> * 希尔排序</div><div class="line"> * 		加强版的插入排序</div><div class="line"> * <span class="doctag">@author</span> Demons</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Shell</span> </span>&#123;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparable[] a)</span></span>&#123;</div><div class="line">		<span class="comment">// 将a[]按照升序排列</span></div><div class="line">		<span class="keyword">int</span> N = a.length;</div><div class="line">		<span class="keyword">int</span> h = <span class="number">1</span>;</div><div class="line">		<span class="keyword">while</span>(h &lt; N/<span class="number">3</span>)&#123;</div><div class="line">			h = <span class="number">3</span> * h + <span class="number">1</span>; <span class="comment">// 1,4,13,40,121....</span></div><div class="line">		&#125;</div><div class="line">		<span class="keyword">while</span>(h &gt;= <span class="number">1</span>)&#123;</div><div class="line">			<span class="comment">// 将数组变为h有序</span></div><div class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> i = h; i &lt; N; i++) &#123;</div><div class="line">				<span class="comment">// 将a[i]插入到a[i-h],a[i-2*h],a[i-3*h]...之中</span></div><div class="line">				<span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &gt;= h &amp;&amp; less(a[j], a[j-h]); j-=h) &#123;</div><div class="line">					exch(a, j, j-h);</div><div class="line">				&#125;</div><div class="line">			&#125;</div><div class="line">			h = h / <span class="number">3</span>;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">less</span><span class="params">(Comparable v, Comparable w)</span></span>&#123;</div><div class="line">		<span class="keyword">return</span> v.compareTo(w) &lt; <span class="number">0</span>;</div><div class="line">	&#125;</div><div class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">exch</span><span class="params">(Comparable[] a, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span>&#123;</div><div class="line">		Comparable t = a[i];</div><div class="line">		a[i] = a[j];</div><div class="line">		a[j] = t;</div><div class="line">	&#125;</div><div class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">(Comparable[] a)</span></span>&#123;</div><div class="line">		<span class="comment">// 在单行中打印数组</span></div><div class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;a.length; i++)&#123;</div><div class="line">			StdOut.print(a[i]+<span class="string">" "</span>);</div><div class="line">		&#125;</div><div class="line">		StdOut.println();</div><div class="line">	&#125;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isSorted</span><span class="params">(Comparable[] a)</span></span>&#123;</div><div class="line">		<span class="comment">// 测试数组元素是否有序</span></div><div class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;a.length; i++)&#123;</div><div class="line">			<span class="keyword">if</span>(less(a[i], a[i-<span class="number">1</span>]))&#123;</div><div class="line">				<span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>有经验的程序员有时会选择希尔排序，因为对于中等大小的数组它的运行时间是可接受的。它的代码量很小而且不需要使用额外的内存空间。在下面的内容中，我们会看到更加高效的算法，但是除了很大的N，它们可能只比希尔排序快两倍(可能还达不到)，而且更复杂，如果你需要解决一个排序问题而又没有系统排序函数可用(例如直接接触硬件或运行嵌入式系统中的代码)，可以先用希尔排序，而后再考虑是否值得将它替换为更为复杂的排序算法。</p>
<h4 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h4><blockquote>
<p>要将一个数组排序，可以先(递归地)将它分成两半分别排序，然后将结果归并起来。归并排序最吸引人的性质是它能保证将任意长度为N的数组排序所需的时间和NlogN成正比 ，它主要的缺点则是它所需的额外的空间和N成正比。</p>
</blockquote>
<h5 id="自顶向下的归并排序"><a href="#自顶向下的归并排序" class="headerlink" title="自顶向下的归并排序"></a>自顶向下的归并排序</h5><blockquote>
<p>思想：</p>
<ul>
<li>如果她能将两个子数组排序，它就能够通过归并两个子数组来将整个数组排序。</li>
<li>sort()方法的作用其实是在于安排多次merge()方法调用的正确顺序。</li>
</ul>
<p>实现：</p>
<ul>
<li>要对子数组a[lo..hi]进行排序，先将它分为a[lo..mid] 和 a[mid+1..hi]两部分，分别通过递归调用将他们单独排序，</li>
<li>最后将有序的子数组归并为最终的排序结果。</li>
</ul>
<p>结论：</p>
<ul>
<li>对于长度为N的任意数组，自顶向下的归并排序需要 1/2NlogN 至 NlogN 次比较。</li>
<li>对于长度为N的任意数组，自顶向下的归并排序最多需要访问数组 6NlogN 次。</li>
</ul>
</blockquote>
<p>代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> sort.merge;</div><div class="line"></div><div class="line"><span class="keyword">import</span> edu.princeton.cs.algs4.StdOut;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * 归并排序</div><div class="line"> * 		自顶向下的归并排序</div><div class="line"> * <span class="doctag">@author</span> Demons</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Merge</span> </span>&#123;</div><div class="line">	</div><div class="line">	<span class="keyword">private</span> <span class="keyword">static</span> Comparable[] aux; <span class="comment">// 归并所需的辅助数组</span></div><div class="line">	</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparable[] a)</span></span>&#123;</div><div class="line">		aux = <span class="keyword">new</span> Comparable[a.length];	<span class="comment">// 一次性分配空间</span></div><div class="line">		sort(a, <span class="number">0</span>, a.length-<span class="number">1</span>);</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparable[] a, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span> </span>&#123;</div><div class="line">		<span class="comment">// 将数组a[lo..hi]排序</span></div><div class="line">		<span class="keyword">if</span>(hi &lt;= lo) <span class="keyword">return</span>;</div><div class="line">		<span class="keyword">int</span> mid = lo + (hi - lo) / <span class="number">2</span>;</div><div class="line">		sort(a, lo ,mid); <span class="comment">// 递归的将左半边排序</span></div><div class="line">		sort(a, mid+<span class="number">1</span>, hi); <span class="comment">// 递归的将右半边排序</span></div><div class="line">		<span class="keyword">if</span>(less(a[mid+<span class="number">1</span>], a[mid]))&#123; <span class="comment">// 当右半边的第一个元素大于左半边的最后一个元素时，视为数组已经有序，跳过归并</span></div><div class="line">			merge(a, lo, mid, hi); <span class="comment">// 归并结果</span></div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="comment">/* 原地归并的抽象方法 */</span></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(Comparable[] a, <span class="keyword">int</span> lo, <span class="keyword">int</span> mid, <span class="keyword">int</span> hi)</span></span>&#123;</div><div class="line">		<span class="comment">// 将a[lo..mid] 和 a[mid+1..hi] 归并</span></div><div class="line">		<span class="keyword">int</span> i = lo;</div><div class="line">		<span class="keyword">int</span> j = mid + <span class="number">1</span>;</div><div class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> k = lo; k &lt;= hi; k++) &#123;</div><div class="line">			<span class="comment">// 将a[lo..hi] 复制到 aux[lo..hi]</span></div><div class="line">			aux[k]  = a[k];</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> k = lo; k &lt;= hi; k++) &#123; </div><div class="line">			<span class="comment">// 归并回a[lo..hi]</span></div><div class="line">			<span class="keyword">if</span>(i &gt; mid)&#123;</div><div class="line">				a[k] = aux[j++]; <span class="comment">// 左半边用尽，取右半边元素</span></div><div class="line">			&#125;<span class="keyword">else</span> <span class="keyword">if</span>(j &gt; hi)&#123;</div><div class="line">				a[k] = aux[i++]; <span class="comment">// 右半边用尽，取左半边元素</span></div><div class="line">			&#125;<span class="keyword">else</span> <span class="keyword">if</span>(less(aux[j], aux[i]))&#123;</div><div class="line">				a[k] = aux[j++]; <span class="comment">// 右半边的当前元素小于左半边的当前元素，取右半边元素</span></div><div class="line">			&#125;<span class="keyword">else</span>&#123;</div><div class="line">				a[k] = aux[i++]; <span class="comment">// 右半边的当前元素大于等于左半边当前元素，取左半边元素</span></div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">less</span><span class="params">(Comparable v, Comparable w)</span></span>&#123;</div><div class="line">		<span class="keyword">return</span> v.compareTo(w) &lt; <span class="number">0</span>;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">(Comparable[] a)</span></span>&#123;</div><div class="line">		<span class="comment">// 在单行中打印数组</span></div><div class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;a.length; i++)&#123;</div><div class="line">			StdOut.print(a[i]+<span class="string">" "</span>);</div><div class="line">		&#125;</div><div class="line">		StdOut.println();</div><div class="line">	&#125;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isSorted</span><span class="params">(Comparable[] a)</span></span>&#123;</div><div class="line">		<span class="comment">// 测试数组元素是否有序</span></div><div class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;a.length; i++)&#123;</div><div class="line">			<span class="keyword">if</span>(less(a[i], a[i-<span class="number">1</span>]))&#123;</div><div class="line">				<span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<blockquote>
<p>命题1：对于长度为N的任意数组，自顶向下的归并排序需要1/2NlgN至NlgN次比较。<br>命题2：对于长度为N的任意数组，自顶向下的归并排序最多需要访问数组6NlgN次。</p>
</blockquote>
<p>命题1和命题2告诉我们，归并排序所需的时间和NlgN成正比。它表明我们只需要比遍历整个数组多个对数因子的时间就能将一个庞大的数组排序。可以用归并处理百万甚至更大规模的数组，这是插入排序或选择排序做不到的。归并排序的缺点是辅助数组所使用的额外空间和N的大小成正比。</p>
<h5 id="自底向上的归并排序"><a href="#自底向上的归并排序" class="headerlink" title="自底向上的归并排序"></a>自底向上的归并排序</h5><blockquote>
<p>思想：</p>
<ul>
<li>自底向上的归并排序会多次遍历整个数组，根据子数组大小进行两两归并。</li>
<li>子数组的大小sz的初始值为1，每次加倍。最后一个子数组的大小只有在数组大小是sz的偶数倍的时候才会等于sz(否则它会比sz小)。</li>
</ul>
</blockquote>
<p>代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> sort.merge;</div><div class="line"></div><div class="line"><span class="keyword">import</span> edu.princeton.cs.algs4.StdOut;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * 自底向上的归并排序</div><div class="line"> * <span class="doctag">@author</span> Demons</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MergeBU</span> </span>&#123;</div><div class="line">	<span class="keyword">private</span> <span class="keyword">static</span> Comparable[] aux; <span class="comment">//归并所需的辅助数组</span></div><div class="line">	</div><div class="line">	<span class="comment">/* 原地归并的抽象方法 */</span></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(Comparable[] a, <span class="keyword">int</span> lo, <span class="keyword">int</span> mid, <span class="keyword">int</span> hi)</span></span>&#123;</div><div class="line">		<span class="comment">// 将a[lo..mid] 和 a[mid+1..hi] 归并</span></div><div class="line">		<span class="keyword">int</span> i = lo;</div><div class="line">		<span class="keyword">int</span> j = mid + <span class="number">1</span>;</div><div class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> k = lo; k &lt;= hi; k++) &#123;</div><div class="line">			<span class="comment">// 将a[lo..hi] 复制到 aux[lo..hi]</span></div><div class="line">			aux[k]  = a[k];</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> k = lo; k &lt;= hi; k++) &#123; </div><div class="line">			<span class="comment">// 归并回a[lo..hi]</span></div><div class="line">			<span class="keyword">if</span>(i &gt; mid)&#123;</div><div class="line">				a[k] = aux[j++]; <span class="comment">// 左半边用尽，取右半边元素</span></div><div class="line">			&#125;<span class="keyword">else</span> <span class="keyword">if</span>(j &gt; hi)&#123;</div><div class="line">				a[k] = aux[i++]; <span class="comment">// 右半边用尽，取左半边元素</span></div><div class="line">			&#125;<span class="keyword">else</span> <span class="keyword">if</span>(less(aux[j], aux[i]))&#123;</div><div class="line">				a[k] = aux[j++]; <span class="comment">// 右半边的当前元素小于左半边的当前元素，取右半边元素</span></div><div class="line">			&#125;<span class="keyword">else</span>&#123;</div><div class="line">				a[k] = aux[i++]; <span class="comment">// 右半边的当前元素大于等于左半边当前元素，取左半边元素</span></div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparable[] a)</span></span>&#123;</div><div class="line">		<span class="comment">// 进行lgN次两两归并</span></div><div class="line">		<span class="keyword">int</span> N = a.length;</div><div class="line">		aux = <span class="keyword">new</span> Comparable[N];</div><div class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> sz = <span class="number">1</span>; sz &lt; N; sz = sz+sz)&#123; <span class="comment">// sz子数组大小</span></div><div class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> lo = <span class="number">0</span>; lo &lt;= N - sz; lo += sz+sz)&#123; <span class="comment">// lo:子数组索引</span></div><div class="line">				merge(a, lo, lo+sz-<span class="number">1</span>, Math.min(lo+sz+sz-<span class="number">1</span>, N-<span class="number">1</span>));</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">less</span><span class="params">(Comparable v, Comparable w)</span></span>&#123;</div><div class="line">		<span class="keyword">return</span> v.compareTo(w) &lt; <span class="number">0</span>;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">(Comparable[] a)</span></span>&#123;</div><div class="line">		<span class="comment">// 在单行中打印数组</span></div><div class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;a.length; i++)&#123;</div><div class="line">			StdOut.print(a[i]+<span class="string">" "</span>);</div><div class="line">		&#125;</div><div class="line">		StdOut.println();</div><div class="line">	&#125;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isSorted</span><span class="params">(Comparable[] a)</span></span>&#123;</div><div class="line">		<span class="comment">// 测试数组元素是否有序</span></div><div class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;a.length; i++)&#123;</div><div class="line">			<span class="keyword">if</span>(less(a[i], a[i-<span class="number">1</span>]))&#123;</div><div class="line">				<span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><strong>当数组长度为2的幂时，</strong>自顶向下和自底向上的归并排序所用的比较次数和数组访问次数正好相同。只是顺序不同。</p>
<p>自底向上的归并排序比较适合用链表组织的数据。想象一下将链表先按大小为1的子链表进行排序，然后是大小为2的子链表，然后是大小为4的子链表等。这种方法只需要重新组织链表链接就能将链表原地排序(不需要创建任何新的链表结点)。</p>
<p>用自顶向下或是自底向上的方式实现任何分治类的算法都很自然。归并排序告诉我们，当能够利用其中一种方法解决一个问题时，你都应该试试第二种。你是希望像<code>Merge.sort()</code>中那样化整为零(然后递归的解决它们)的方式解决问题，还是希望像<code>MergeBU.sort()</code>中那样循序渐进的解决问题呢？</p>
<h4 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h4><h5 id="快速排序-1"><a href="#快速排序-1" class="headerlink" title="快速排序"></a>快速排序</h5><blockquote>
<p>他可能是应用最广泛的排序算法了。快速排序流行的原因是它实现简单、适用于各种不同输入数据且在一般应用中比其他排序算法都要快得多。<br>快速排序引人注目的特点包括它是原地排序(只需要一个很小的辅助栈)，且将长度为N的数组排序所需要的时间和NlgN成正比。<br>它的主要缺点是非常脆弱，在实现时要非常小心才能避免低劣的性能。</p>
<p>思路：通过递归的调用切分来实现排序。</p>
<p>实现：</p>
<ul>
<li>先取a[lo]作为切分元素v，即那个将会被排定的元素。</li>
<li>在循环中，a[i]小于v时，我们增大i。a[j]大于v时，我们减小j。</li>
<li>当遇到a[i]大于v且a[j]小于v时，我们交换a[i]和a[j]。保证i左侧的元素都不大于v，j右侧的元素都不小于V。</li>
<li>当指针相遇时，我们交换a[lo]和a[j],切分结束。这样切分值就留在了a[j]中了。</li>
</ul>
</blockquote>
<p>代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> sort.quick;</div><div class="line"></div><div class="line"><span class="keyword">import</span> edu.princeton.cs.algs4.StdOut;</div><div class="line"><span class="keyword">import</span> edu.princeton.cs.algs4.StdRandom;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * 快速排序</div><div class="line"> * <span class="doctag">@author</span> Demons</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Quick</span> </span>&#123;</div><div class="line">	</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparable[] a)</span></span>&#123;</div><div class="line"><span class="comment">//		StdRandom.shuffle(a);	// 清除对输入的依赖</span></div><div class="line">		sort(a, <span class="number">0</span>, a.length-<span class="number">1</span>);</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparable[] a, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span></span>&#123;</div><div class="line">		<span class="keyword">if</span>(hi &lt;= lo) <span class="keyword">return</span>; <span class="comment">// 终止递归</span></div><div class="line">		<span class="keyword">int</span> j = partition(a, lo, hi);	<span class="comment">// 切分</span></div><div class="line">		sort(a, lo, j-<span class="number">1</span>);</div><div class="line">		sort(a, j+<span class="number">1</span>, hi);</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(Comparable[] a, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span></span>&#123;</div><div class="line">		<span class="keyword">int</span> i = lo, j = hi+<span class="number">1</span>;	<span class="comment">// 左右扫描指针</span></div><div class="line">		Comparable v = a[lo];	<span class="comment">// 切分元素</span></div><div class="line">		<span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</div><div class="line">			<span class="comment">// 扫描左右，检查扫描是否结束并交换元素</span></div><div class="line">			<span class="keyword">while</span>(less(a[++i], v))&#123;</div><div class="line">				<span class="keyword">if</span>(i == hi) <span class="keyword">break</span>;</div><div class="line">			&#125;</div><div class="line">			<span class="keyword">while</span>(less(v, a[--j]))&#123;</div><div class="line">				<span class="keyword">if</span>(j == lo) <span class="keyword">break</span>;</div><div class="line">			&#125;</div><div class="line">			<span class="keyword">if</span>(i &gt;= j) <span class="keyword">break</span>;</div><div class="line">			exch(a, i, j);</div><div class="line">		&#125;</div><div class="line">		exch(a, lo, j);	<span class="comment">// 将v=a[j]放入正确的位置</span></div><div class="line">		<span class="keyword">return</span> j;</div><div class="line">	&#125;</div><div class="line">	<span class="comment">// 比较</span></div><div class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">less</span><span class="params">(Comparable v, Comparable w)</span></span>&#123;</div><div class="line">		<span class="keyword">return</span> v.compareTo(w) &lt; <span class="number">0</span>;</div><div class="line">	&#125;</div><div class="line">	<span class="comment">// 交换</span></div><div class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">exch</span><span class="params">(Comparable[] a, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span>&#123;</div><div class="line">		Comparable t = a[i];</div><div class="line">		a[i] = a[j];</div><div class="line">		a[j] = t;</div><div class="line">	&#125;</div><div class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">(Comparable[] a)</span></span>&#123;</div><div class="line">		<span class="comment">// 在单行中打印数组</span></div><div class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;a.length; i++)&#123;</div><div class="line">			StdOut.print(a[i]+<span class="string">" "</span>);</div><div class="line">		&#125;</div><div class="line">		StdOut.println();</div><div class="line">	&#125;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isSorted</span><span class="params">(Comparable[] a)</span></span>&#123;</div><div class="line">		<span class="comment">// 测试数组元素是否有序</span></div><div class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;a.length; i++)&#123;</div><div class="line">			<span class="keyword">if</span>(less(a[i], a[i-<span class="number">1</span>]))&#123;</div><div class="line">				<span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>快速排序切分方法的内循环会用一个递增的索引将数组元素和一个定值比较。这种简洁性也是快速排序的一个优点，很难想象排序算法中还能有比这更短小的内循环了。</p>
<p>快速排序另一个速度优势是它的比较次数很少。排序效率最终还是依赖切分数组的效果。而这依赖于切分元素的值。切分将一个较大的随机数组分成两个随机子数组，而实际上这种分割可能发生在数组的任意位置(对于元素不重复的数组而言)。</p>
<p>尽管快速排序有很多优点，它的基本实现仍有一个潜在的缺点：在切分不平衡时这个程序可能会极为低效。例如，如果第一次从最小的元素切分，第二次从第二小的元素切分，如此这般，每次调用只能移除一个元素。这会导致一个大子数组需要切分很多次。我们要在快速排序前将数组随机排序的主要原因就是要避免这种情况。</p>
<h5 id="三向切分的快速排序"><a href="#三向切分的快速排序" class="headerlink" title="三向切分的快速排序"></a>三向切分的快速排序</h5><blockquote>
<p>在有大量重复元素的情况下，快速排序的递归性会使元素全部重复的子数组经常出现，这就有很大的该井潜力，将当前实现的线性对数级的性能提高到线性级别。</p>
<p>一个简单的想法是将数组切分为3部分，分别对应小于、等于喝大于切分元素的数组元素。这种切分实现起来比我们目前使用的二分法更复杂。</p>
<p>思路：</p>
<ul>
<li>从左至右遍历数组一次，维护一个指针lt使得a[lo..lt-1]中的元素都小于v；</li>
<li>一个指针gt使得a[gt+1..hi]中的元素都大于v；</li>
<li>一个指针i，使得a[lt..i-1]中的元素都等于v；</li>
<li>当while循环中的i==gt成立时，a[lo..lt-1] &lt; v = a[lt..gt] &lt; a[gt+1..hi]成立。</li>
</ul>
<p>性能：</p>
<ul>
<li>对于包含大量重复元素的数组，三向切分将排序时间从线性对数级别降低到了线性级别。</li>
<li>经过精心调优的快速排序在绝大多数计算机上的绝大多数应用中都会比其他基于比较的排序算法更快。</li>
</ul>
</blockquote>
<p>代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> sort.quick;</div><div class="line"></div><div class="line"><span class="keyword">import</span> edu.princeton.cs.algs4.StdOut;</div><div class="line"><span class="keyword">import</span> edu.princeton.cs.algs4.StdRandom;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * 三向切分的快速排序</div><div class="line"> * <span class="doctag">@author</span> Demons</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Quick3way</span> </span>&#123;</div><div class="line">	</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparable[] a)</span></span>&#123;</div><div class="line">		StdRandom.shuffle(a);	<span class="comment">// 清除对输入的依赖</span></div><div class="line">		sort(a, <span class="number">0</span>, a.length-<span class="number">1</span>);</div><div class="line">	&#125;</div><div class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparable[] a, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span></span>&#123;</div><div class="line">		<span class="keyword">if</span>(hi &lt;= lo) <span class="keyword">return</span>;</div><div class="line">		<span class="keyword">int</span> lt = lo, i = lo+<span class="number">1</span>, gt = hi;</div><div class="line">		Comparable v = a[lo]; <span class="comment">// 用来比较的v，为数组的第一个元素</span></div><div class="line">		<span class="keyword">while</span>(i &lt;= gt)&#123;</div><div class="line">			<span class="keyword">int</span> cmp = a[i].compareTo(v);</div><div class="line">			<span class="keyword">if</span>(cmp &lt; <span class="number">0</span>)&#123; <span class="comment">// a[i] &lt; v</span></div><div class="line">				exch(a, lt++, i++); <span class="comment">// 将a[lt]和a[i]交换，将lt和i加1；</span></div><div class="line">			&#125;<span class="keyword">else</span> <span class="keyword">if</span>(cmp &gt; <span class="number">0</span>)&#123; <span class="comment">// a[i] &gt; v</span></div><div class="line">				exch(a, i, gt--); <span class="comment">// 将a[gt]和a[i]交换，将gt减1；</span></div><div class="line">			&#125;<span class="keyword">else</span>&#123; <span class="comment">// a[i] = v</span></div><div class="line">				i++; </div><div class="line">			&#125; <span class="comment">// 现在a[lo..lt-1] &lt; v = a[lt..gt] &lt; a[gt+1..hi]成立</span></div><div class="line">		&#125;</div><div class="line">		sort(a, lo, lt-<span class="number">1</span>);</div><div class="line">		sort(a, gt+<span class="number">1</span>, hi);</div><div class="line">	&#125;</div><div class="line">	<span class="comment">// 比较</span></div><div class="line">		<span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">less</span><span class="params">(Comparable v, Comparable w)</span></span>&#123;</div><div class="line">			<span class="keyword">return</span> v.compareTo(w) &lt; <span class="number">0</span>;</div><div class="line">		&#125;</div><div class="line">		<span class="comment">// 交换</span></div><div class="line">		<span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">exch</span><span class="params">(Comparable[] a, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span>&#123;</div><div class="line">			Comparable t = a[i];</div><div class="line">			a[i] = a[j];</div><div class="line">			a[j] = t;</div><div class="line">		&#125;</div><div class="line">		<span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">(Comparable[] a)</span></span>&#123;</div><div class="line">			<span class="comment">// 在单行中打印数组</span></div><div class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;a.length; i++)&#123;</div><div class="line">				StdOut.print(a[i]+<span class="string">" "</span>);</div><div class="line">			&#125;</div><div class="line">			StdOut.println();</div><div class="line">		&#125;</div><div class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isSorted</span><span class="params">(Comparable[] a)</span></span>&#123;</div><div class="line">			<span class="comment">// 测试数组元素是否有序</span></div><div class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;a.length; i++)&#123;</div><div class="line">				<span class="keyword">if</span>(less(a[i], a[i-<span class="number">1</span>]))&#123;</div><div class="line">					<span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">				&#125;</div><div class="line">			&#125;</div><div class="line">			<span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">		&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h4><blockquote>
<p>堆有序：当一颗二叉树的每个结点都大于等于它的两个子结点时，它被称为堆有序。<br>二叉堆：是一组能够用堆有序的完全二叉树排序的元素，并在数组中按照层级存储(不使用数组的第一个位置)。<br>性质：位置K的结点的父结点的位置为K/2，而它两个子结点的位置分别是2K和2K+1</p>
<p>堆排序可以分为两个阶段：</p>
<ul>
<li>堆的构造阶段：将原始数组重新组织安排进一个堆中。</li>
<li>下沉排序阶段：按递减的顺序取出所有元素，并得到排序结果。</li>
</ul>
<p>性能：将N个元素排序，堆排序只需要少于2NlogN+2N次比较以及一半次数的交换。</p>
</blockquote>
<p>代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> sort.heap;</div><div class="line"></div><div class="line"><span class="keyword">import</span> edu.princeton.cs.algs4.StdOut;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * 堆排序</div><div class="line"> * <span class="doctag">@author</span> Demons</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Heap</span> </span>&#123;</div><div class="line"></div><div class="line">	<span class="comment">// 不能被实例化</span></div><div class="line">	<span class="function"><span class="keyword">private</span> <span class="title">Heap</span><span class="params">()</span></span>&#123;&#125;</div><div class="line">	</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparable[] a)</span></span>&#123;</div><div class="line">		<span class="keyword">int</span> N = a.length;</div><div class="line">		<span class="comment">// 构造堆，堆有序 </span></div><div class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> k = N/<span class="number">2</span>; k &gt;= <span class="number">1</span>; k--) &#123; <span class="comment">// 我们只需要扫描数组中一半的元素，因为可以跳过大小为1的子堆</span></div><div class="line">			sink(a, k, N);</div><div class="line">		&#125;</div><div class="line">		<span class="comment">// 下沉排序</span></div><div class="line">		<span class="keyword">while</span>(N &gt;<span class="number">1</span>)&#123;</div><div class="line">			exch(a, <span class="number">1</span>, N--); <span class="comment">// 将最大的元素a[i]和a[N]交换，并将最大元素删除，放入堆缩小后空出来的位置。</span></div><div class="line">			sink(a, <span class="number">1</span>, N); <span class="comment">// 修复堆，再将堆中最大的元素置换出来</span></div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sink</span><span class="params">(Comparable[] a, <span class="keyword">int</span> k, <span class="keyword">int</span> N)</span></span>&#123;</div><div class="line">		<span class="keyword">while</span>(<span class="number">2</span>*k &lt;= N)&#123;</div><div class="line">			<span class="keyword">int</span> j = <span class="number">2</span>*k; <span class="comment">// j,j+1为k的两个子结点</span></div><div class="line">			<span class="keyword">if</span>(j &lt; N &amp;&amp; less(a, j, j+<span class="number">1</span>)) j++; <span class="comment">// 找到较大的子结点</span></div><div class="line">			<span class="keyword">if</span>(!less(a, k, j)) <span class="keyword">break</span>; <span class="comment">// 如果a[k]&gt;a[j],已经置换完成</span></div><div class="line">			exch(a, k, j); </div><div class="line">			k = j;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	<span class="comment">// 二叉堆不使用数组的第一个元素a[0],所以要将数组的索引减1，以将a[0]至a[N-1]排序</span></div><div class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">less</span><span class="params">(Comparable[] a ,<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span>&#123;</div><div class="line">		<span class="keyword">return</span> a[i-<span class="number">1</span>].compareTo(a[j-<span class="number">1</span>]) &lt; <span class="number">0</span>;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">exch</span><span class="params">(Object[] a, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span>&#123;</div><div class="line">		Object swap = a[i-<span class="number">1</span>];</div><div class="line">		a[i-<span class="number">1</span>] = a[j-<span class="number">1</span>];</div><div class="line">		a[j-<span class="number">1</span>] = swap;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">less</span><span class="params">(Comparable v, Comparable w)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> v.compareTo(w) &lt; <span class="number">0</span>;</div><div class="line">    &#125;</div><div class="line">	</div><div class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">(Comparable[] a)</span></span>&#123;</div><div class="line">		<span class="comment">// 在单行中打印数组</span></div><div class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;a.length; i++)&#123;</div><div class="line">			StdOut.print(a[i]+<span class="string">" "</span>);</div><div class="line">		&#125;</div><div class="line">		StdOut.println();</div><div class="line">	&#125;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isSorted</span><span class="params">(Comparable[] a)</span></span>&#123;</div><div class="line">		<span class="comment">// 测试数组元素是否有序</span></div><div class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;a.length; i++)&#123;</div><div class="line">			<span class="keyword">if</span>(less(a[i], a[i-<span class="number">1</span>]))&#123;</div><div class="line">				<span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>堆的构造阶段：我们可以使用<code>sink()</code>函数从左至右的构造子堆。如果一个结点的两个子结点都已经是堆了，那么在这个结点上调用<code>sink()</code>可以将它们变成一个堆。开始时我们只需要扫描数组一半的元素，因为我们可以跳过大小为1的子堆。最后我们在位置1上调用<code>sink()</code>方法，扫描结束。</p>
<p>下沉排序阶段：将堆中最大的元素删除，然后放入堆缩小后数组中空出的位置。每次下沉排序都会将最大元素放到数组的末尾并将除了末尾最大元素外的最大元素放到数组的首位。这个过程和选择排序比较类似，但所需的比较要少得多，因为堆提供了一种从未排序部分找到最大元素的有效方法。</p>

      
    </div>
    <div class="article-info article-info-index">
      
      <a href="/2016/11/09/排序算法/" class="archive-article-date">
  	<time datetime="2016-11-09T02:05:55.000Z" itemprop="datePublished"><i class="icon-clock"></i>2016-11-09</time>
</a>
      
	<div class="article-tag tagcloud">
		<i class="icon-price-tags"></i>
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/数据结构/">数据结构</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/算法/">算法</a></li></ul>
	</div>

      

      <div class="clearfix"></div>
    </div>
  </div>
</article>

  
<nav id="article-nav">
  
    <a href="/2016/11/17/红黑树的插入算法/" id="article-nav-newer" class="article-nav-link-wrap">
      <i class="icon-circle-left"></i>
      <div class="article-nav-title">
        
          红黑树的插入算法
        
      </div>
    </a>
  
  
    <a href="/2016/10/31/基于二叉查找树的符号表-BST/" id="article-nav-older" class="article-nav-link-wrap">
      <div class="article-nav-title">基于二叉查找树的符号表(BST)</div>
      <i class="icon-circle-right"></i>
    </a>
  
</nav>




<div class="share_jia">
	<!-- JiaThis Button BEGIN -->
	<div class="jiathis_style">
		<span class="jiathis_txt">Share to: &nbsp; </span>
		<a class="jiathis_button_facebook"></a> 
	    <a class="jiathis_button_twitter"></a>
	    <a class="jiathis_button_plus"></a> 
	    <a class="jiathis_button_tsina"></a>
		<a class="jiathis_button_cqq"></a>
		<a class="jiathis_button_douban"></a>
		<a class="jiathis_button_weixin"></a>
		<a class="jiathis_button_tumblr"></a>
    <a href="http://www.jiathis.com/share" class="jiathis jiathis_txt jtico jtico_jiathis" target="_blank"></a>
	</div>
	<script type="text/javascript" src="//v3.jiathis.com/code/jia.js?uid=1405949716054953" charset="utf-8"></script>
	<!-- JiaThis Button END -->
</div>






<div class="duoshuo">
	<!-- 多说评论框 start -->
	<div class="ds-thread" data-thread-key="排序算法" data-title="排序算法" data-url="//litten.me/2016/11/09/排序算法/"></div>
	<!-- 多说评论框 end -->
	<!-- 多说公共JS代码 start (一个网页只需插入一次) -->
	<script type="text/javascript">
	var duoshuoQuery = {short_name:"wangxuan"};
	(function() {
		var ds = document.createElement('script');
		ds.type = 'text/javascript';ds.async = true;
		ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
		ds.charset = 'UTF-8';
		(document.getElementsByTagName('head')[0] 
		 || document.getElementsByTagName('body')[0]).appendChild(ds);
	})();
	</script>
	<!-- 多说公共JS代码 end -->
</div>





      </div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info">
    	<div class="footer-left">
    		&copy; 2016 Demons
    	</div>
      	<div class="footer-right">
      		<a href="http://hexo.io/" target="_blank">Hexo</a>  Theme <a href="https://github.com/litten/hexo-theme-yilia" target="_blank">Yilia</a> by Litten
      	</div>
    </div>
  </div>
</footer>
    </div>
    <script>
	var yiliaConfig = {
		fancybox: true,
		mathjax: false,
		animate: true,
		isHome: false,
		isPost: true,
		isArchive: false,
		isTag: false,
		isCategory: false,
		open_in_new: true,
		root: "/",
		innerArchive: true
	}
</script>

<script src="/./main.js"></script>


    
<div class="tools-col">
  <ul class="btn-wrap">
    
      <li class="chose" data-hook="tools-section-all"><span class="text">全部</span><i class="icon-book"></i></li>
    
    
      <li data-hook="tools-section-tag"><span class="text">标签</span><i class="icon-price-tags"></i></li>
    
    
    
      <li data-hook="tools-section-me"><span class="text">我</span><i class="icon-smile"></i></li>
    
  </ul>
  <div class="tools-wrap">
    
    	<section class="tools-section tools-section-all chose">
    	</section>
    

    
    	<section class="tools-section tools-section-tag">
    			<div class="widget tagcloud" id="js-tagcloud">
    				<a href="/tags/GitHub/" style="font-size: 10px;">GitHub</a> <a href="/tags/Java/" style="font-size: 10px;">Java</a> <a href="/tags/spark/" style="font-size: 10px;">spark</a> <a href="/tags/大数据/" style="font-size: 10px;">大数据</a> <a href="/tags/数据结构/" style="font-size: 20px;">数据结构</a> <a href="/tags/查找/" style="font-size: 10px;">查找</a> <a href="/tags/生活/" style="font-size: 10px;">生活</a> <a href="/tags/算法/" style="font-size: 15px;">算法</a>
    			</div>
    	</section>
    

    

    
    	<section class="tools-section tools-section-me">
  	  	
  	  		<div class="aboutme-wrap" id="js-aboutme">wangxuan，一个无知的人。</div>
  	  	
    	</section>
    
  </div>
  
</div>
    <!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                      <div class="pswp__preloader__cut">
                        <div class="pswp__preloader__donut"></div>
                      </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div> 
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>
  </div>
</body>
</html>